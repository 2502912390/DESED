import glob
import os
from os import path as osp

import random
import jams
import numpy as np
import pandas as pd
import soundfile as sf
import scaper
from scaper import generate_from_jams

from .utils import add_event, choose_cooccurence_class, create_folder, get_df_from_jams, post_process_df, choose_file
from .Logger import create_logger


def modify_bg_snr(new_snr, jam_file):
    """ Modify the background SNR of a JAMS generated by scaper
    Args:
        new_snr: float, Sound to noise ratio (SNR) of the background from the reference
        jam_file: str, the name of the JAMS file to change the background SNR

    Returns:
        jams object that has been modified
    """
    jam_obj = jams.load(jam_file)
    data = jam_obj["annotations"][0].data
    for cnt, obs in enumerate(data):
        if obs.value["role"] == "background":
            # Changing manually the jams to have the snr desired
            jam_obj["annotations"][0].data[cnt].value["snr"] = new_snr

    return jam_obj


def generate_new_bg_snr_files(new_snr, in_dir, out_dir):
    """ Generate the new JAMS and audio files with a different background SNR
    Args:
        new_snr: float, Sound to noise ratio (SNR) of the background from the reference
        in_dir: str, folder containing JAMS file with background SNR to be changed
        out_dir: str, folder where to save the new audio and JAMS

    Returns:

    """
    logger = create_logger(__name__, "Desed.log")
    create_folder(out_dir)
    for jam_file in sorted(glob.glob(os.path.join(in_dir, "*.jams"))):
        jams_obj = modify_bg_snr(new_snr, jam_file)
        out_jams = osp.join(out_dir, os.path.basename(jam_file))
        jams_obj.save(out_jams)

        audiofile = os.path.join(out_dir, osp.splitext(osp.basename(jam_file))[0] + ".wav")
        logger.debug(audiofile)
        scaper.generate_from_jams(out_jams, audiofile)


def modify_fg_onset(added_value, jam_file):
    """ Add a value foreground onset of a JAMS generated by scaper (containing a single event)
    Args:
        added_value: float, value in seconds, value to be added to previous onset
        jam_file: str, the name of the JAMS file to change the background SNR

    Returns:
        jams object that has been modified
    """
    jam_obj = jams.load(jam_file)
    data = jam_obj["annotations"][0].data
    for cnt, obs in enumerate(data):
        if obs.value["role"] == "foreground":
            onset = obs.value["event_time"]
            # Change source time by adding the added value specified
            jam_obj["annotations"][0].data[cnt].value["event_time"] = onset + added_value
            # Todo, this is tricky, because it is an object, find a better way to do that with Scaper
            new_obs = jam_obj["annotations"][0].data[cnt]._replace(time=onset + added_value)
            del jam_obj["annotations"][0].data[cnt]
            jam_obj["annotations"][0].data.add(new_obs)

    return jam_obj


def generate_new_fg_onset_files(added_value, in_dir, out_dir):
    """ Generate the new JAMS and audio files adding a value to forground onsets
    Args:
        added_value: float, value in seconds, value to be added to previous onset
        in_dir: str, folder containing JAMS file with background SNR to be changed
        out_dir: str, folder where to save the new audio and JAMS

    Returns:

    """
    logger = create_logger(__name__, "Desed.log")
    create_folder(out_dir)
    for jam_file in sorted(glob.glob(os.path.join(in_dir, "*.jams"))):
        jams_obj = modify_fg_onset(added_value, jam_file)
        out_jams = osp.join(out_dir, os.path.basename(jam_file))
        jams_obj.save(out_jams)

        audiofile = os.path.join(out_dir, osp.splitext(osp.basename(jam_file))[0] + ".wav")
        logger.debug(audiofile)
        scaper.generate_from_jams(out_jams, audiofile)


def initialize_scaper(duration, fg_folder, bg_folder, ref_db):
    """ Initialize scaper object with a reference dB.
    Args:
        duration: float, in seconds, the duration of the generated audio clip.
        fg_folder: str, path of foreground files (be careful, need subfolders, one per class or group)
        bg_folder: str, path of background files (be careful, need subfolders, one per group)
        ref_db: float, the reference dB of the clip.

    Returns:
        scaper.Scaper object

    """
    sc = scaper.Scaper(duration, fg_folder, bg_folder)
    sc.protected_labels = []
    sc.ref_db = ref_db

    return sc


def add_random_background(scaper_obj):
    """ Add random background to a scaper object
    Args:
        scaper_obj: scaper.Scaper, the scaper object in which to add the background.

    Returns:
        scaper.Scaper object with background added.
    """
    chosen_file = choose_file(osp.join(scaper_obj.bg_path, "*"))
    file_duration = sf.info(chosen_file).duration
    starting_source = min(random.random() * file_duration, max(file_duration - scaper_obj.duration, 0))
    scaper_obj.add_background(label=('const', chosen_file.split("/")[-2]),
                              source_file=('const', chosen_file),
                              source_time=('const', starting_source))
    return scaper_obj


def generate_single_file(class_params, class_lbl, ref_db, duration, fg_folder, bg_folder, outfolder, filename,
                         min_events=0):
    """ Generate a single file, using the information of onset or offset present
    (see DESED dataset and folders in soundbank foreground)
    Args:
        class_params: dict, dict containing information about how to mix classes, and the probability of each class.
        class_lbl: str, the main foreground label of the generated file.
        ref_db: float, the reference dB of the clip.
        duration: float, in seconds, the duration of the generated audio clip.
        fg_folder: str, path of foreground files (be careful, need subfolders, one per class or group)
        bg_folder: str, path of background files (be careful, need subfolders, one per group)
        outfolder: str, path to extract generate file
        filename: str, name of the generated file, without extension (.wav, .jams and .txt will be created)
        min_events: int, the minimum number of events to add (on top of the main event), maximum is in class_params.

    Returns:
        None
    """
    # create a scaper
    sc = initialize_scaper(duration, fg_folder, bg_folder, ref_db=ref_db)
    sc = add_random_background(sc)

    # add main event
    sc = add_event(sc, class_lbl)

    # add random number of foreground events
    n_events = np.random.randint(min_events, class_params['event_max'])
    for _ in range(n_events):
        chosen_class = choose_cooccurence_class(class_params)
        sc = add_event(sc, chosen_class)

    # generate
    audiofile = osp.join(outfolder, f"{filename}.wav")
    jamsfile = osp.join(outfolder, f"{filename}.jams")
    txtfile = osp.join(outfolder, f"{filename}.txt")

    sc.generate(audiofile, jamsfile,
                allow_repeated_label=True,
                allow_repeated_source=True,
                reverb=0.1,
                disable_sox_warnings=True,
                no_audio=False,
                txt_path=txtfile)


def generate_files_from_jams(list_jams, outfolder, fg_path=None, bg_path=None, overwrite_jams=False):
    """ Generate audio files from jams files generated by Scaper

    Args:
        list_jams: list, list of jams filepath generated by Scaper.
        outfolder: str, output path to save audio files.
        fg_path: str, optional, path of the foreground files to generate audio if different from the one used to
            generate JAMS
        bg_path: str, optional, path of the background files to generate audio if different from the one used to
            generate JAMS
        overwrite_jams: bool, overwrite the input JAMS with generated ones (update fg and bg path for example)

    Returns: None

    """
    LOG = create_logger(__name__, "Desed.log")
    LOG.info(f"generating audio files to {outfolder}")
    create_folder(outfolder)
    n = 0
    for jam_file in list_jams:
        LOG.debug(jam_file)
        audiofile = osp.join(outfolder, f"{osp.splitext(osp.basename(jam_file))[0]}.wav")
        if overwrite_jams:
            jams_outfile = jam_file
        else:
            jams_outfile = None
        generate_from_jams(jam_file, audiofile, fg_path=fg_path, bg_path=bg_path, jams_outfile=jams_outfile)

        n += 1
        if n % 500 == 0:
            LOG.debug(f"generating {n} / {len(list_jams)} files")
    LOG.info("Done")


def generate_multi_common(number, ref_db, duration, fg_folder, bg_folder, outfolder, min_events, max_events,
                          labels=('choose', []), source_files=('choose', []), sources_time=('const', 0),
                          events_start=('truncnorm', 5.0, 2.0, 0.0, 10.0), events_duration=('uniform', 0.25, 10.0),
                          snrs=('const', 30), pitch_shifts=('uniform', -3.0, 3.0), time_stretches=('uniform', 1, 1),
                          txt_file=True):
    """ Generate

    Args:
        number: int, number of audio clips to create.
        ref_db: float, the dB reference of the clip
        duration: float, in seconds, the duration of the clip
        fg_folder: str, path of foreground files (be careful, need subfolders, one per class or group)
        bg_folder: str, path of background files (be careful, need subfolders, one per group)
        outfolder: str, path to extract generate file
        min_events: int, the minimum number of foreground events to add (pick at random uniformly).
        max_events: int, the maximum number of foreground events to add (pick at random uniformly).
        labels: tuple or list, strategy to choose foreground events (see Scaper) or list of events.
        source_files: tuple or list, strategy to choose source files (see Scaper) or list of source files.
        sources_time: tuple or list, strategy to choose source start time (see Scaper) or list of sources start time.
        events_start: tuple or list, strategy to choose events start time (see Scaper) or list of events start time.
        events_duration: tuple or list, strategy to choose events duation (see Scaper) or list of events duration.
        snrs: tuple or list, strategy to choose foreground to background SNRs (see Scaper) or list of SNRs.
        pitch_shifts: tuple or list, strategy to choose pitch shift (see Scaper) or list of pitch shifts.
        time_stretches: tuple or list, strategy to choose time stretches (see Scaper) or list of time stretches.
        txt_file: bool, whether or not to save the .txt file.

    Returns:
        None
    """
    logger = create_logger(__name__)
    params = {
        'labels': labels,
        'source_files': source_files,
        'sources_time': sources_time,
        'events_start': events_start,
        'events_duration': events_duration,
        'snrs': snrs,
        'pitch_shifts': pitch_shifts,
        'time_stretches': time_stretches
    }

    for n in range(number):
        logger.debug('Generating soundscape: {:d}/{:d}'.format(n + 1, number))
        # create a scaper
        n_events = np.random.randint(min_events, max_events + 1)
        generate_one_bg_multi_fg(ref_db=ref_db,
                                 duration=duration,
                                 fg_folder=fg_folder,
                                 bg_folder=bg_folder,
                                 out_folder=outfolder,
                                 filename=n,
                                 n_fg_events=n_events,
                                 **params,
                                 txt_file=txt_file)


def generate_tsv_from_jams(list_jams, tsv_out, post_process=True, background_label=False):
    """ In scaper.generate they create a txt file for each audio file.
    Using the same idea, we create a single tsv file with all the audio files and their labels.
    Args:
        list_jams: list, list of paths of JAMS files.
        tsv_out: str, path of the tsv to be saved
        post_process: bool, post_process removes small blanks, clean the overlapping same events in the labels and
        make the smallest event 250ms long.
        background_label: bool, include the background label in the annotations.

    Returns:
        None
    """
    final_df = pd.DataFrame()
    for jam_file in list_jams:
        print(jam_file)
        fbase = osp.basename(jam_file)
        df, length = get_df_from_jams(jam_file, background_label=background_label, return_length=True)

        if post_process:
            df, _ = post_process_df(df, length)

        df["filename"] = osp.basename(fbase)
        final_df = final_df.append(df[['filename', 'onset', 'offset', 'event_label']], ignore_index=True)

    final_df = final_df.sort_values(by=["filename", "onset"])
    final_df.to_csv(tsv_out, sep="\t", index=False, float_format="%.3f")


def generate_one_bg_multi_fg(ref_db, duration, fg_folder, bg_folder, out_folder, filename, n_fg_events,
                             labels=('choose', []), source_files=('choose', []), sources_time=('const', 0),
                             events_start=('truncnorm', 5.0, 2.0, 0.0, 10.0), events_duration=("uniform", 0.25, 10.0),
                             snrs=("const", 30), pitch_shifts=('uniform', -3.0, 3.0),
                             time_stretches=('uniform', 1, 1), txt_file=True):
    """ Generate a clip with a background file and multiple foreground files
    Args:
        ref_db: float, the dB reference of the clip
        duration: float, in seconds, the duration of the clip
        fg_folder: str, path of foreground files (be careful, need subfolders, one per class or group)
        bg_folder: str, path of background files (be careful, need subfolders, one per group)
        out_folder: str, path to extract generate file
        filename: str, name of the generated file, without extension (.wav, .jams and .txt will be created)
        n_fg_events: int, the number of foreground events to add
        labels: tuple or list, strategy to choose foreground events (see Scaper) or list of events.
        source_files: tuple or list, strategy to choose source files (see Scaper) or list of source files.
        sources_time: tuple or list, strategy to choose source start time (see Scaper) or list of sources start time.
        events_start: tuple or list, strategy to choose events start time (see Scaper) or list of events start time.
        events_duration: tuple or list, strategy to choose events duation (see Scaper) or list of events duration.
        snrs: tuple or list, strategy to choose foreground to background SNRs (see Scaper) or list of SNRs.
        pitch_shifts: tuple or list, strategy to choose pitch shift (see Scaper) or list of pitch shifts.
        time_stretches: tuple or list, strategy to choose time stretches (see Scaper) or list of time stretches.
        txt_file: bool, whether or not to save the .txt file.

    Returns:
        None
    """
    sc = initialize_scaper(duration, fg_folder, bg_folder, ref_db=ref_db)
    sc = add_random_background(sc)

    params = {"label": labels, "source_file": source_files, "source_time": sources_time, "event_time": events_start,
              "event_duration": events_duration, "snr": snrs, "pitch_shift": pitch_shifts,
              "time_stretch": time_stretches}
    for i in range(n_fg_events):
        event_params = {}
        for key in params:
            if type(params[key]) is tuple:
                param = params[key]
            elif type(params[key]) is list:
                assert len(params[key]) == n_fg_events
                param = params[key][i]
            else:
                raise NotImplementedError("Params of events is tuple(same for all) or list (different for each event)")
            event_params[key] = param

        sc.add_event(**event_params)

    # generate
    audiofile = osp.join(out_folder, f"{filename}.wav")
    jamsfile = osp.join(out_folder, f"{filename}.jams")
    if txt_file:
        # Can be useless if you want background annotation as well, see post_processing_annotations.
        txtfile = osp.join(out_folder, f"{filename}.txt")
    else:
        txtfile = None
    sc.generate(audio_path=audiofile, jams_path=jamsfile,
                allow_repeated_label=True,
                allow_repeated_source=True,
                reverb=0.1,
                disable_sox_warnings=True,
                no_audio=False,
                txt_path=txtfile)
