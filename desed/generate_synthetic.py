import glob
import os
from os import path as osp

import jams
import numpy as np
import pandas as pd
import scaper
from scaper import generate_from_jams

from desed.Logger import create_logger
from desed.utils import get_df_from_jams, post_process_df

from .utils import add_event, choose_class, create_folder
from .Logger import create_logger


def modify_bg_snr(new_snr, jam_file):
    """ Modify the background SNR of a JAMS generated by scaper
    Args:
        new_snr: float, Sound to noise ratio (SNR) of the background from the reference
        jam_file: str, the name of the JAMS file to change the background SNR

    Returns:
        jams object that has been modified
    """
    jam_obj = jams.load(jam_file)
    data = jam_obj["annotations"][0].data
    for cnt, obs in enumerate(data):
        if obs.value["role"] == "background":
            # Changing manually the jams to have the snr desired
            jam_obj["annotations"][0].data[cnt].value["snr"] = new_snr

    return jam_obj


def generate_new_bg_snr_files(new_snr, in_dir, out_dir):
    """ Generate the new JAMS and audio files with a different background SNR
    Args:
        new_snr: float, Sound to noise ratio (SNR) of the background from the reference
        in_dir: str, folder containing JAMS file with background SNR to be changed
        out_dir: str, folder where to save the new audio and JAMS

    Returns:

    """
    LOG = create_logger(__name__, "Desed.log")
    for jam_file in sorted(glob.glob(os.path.join(in_dir, "*.jams"))):
        jams_obj = modify_bg_snr(new_snr, jam_file)
        out_jams = osp.join(out_dir, os.path.basename(jam_file))
        jams_obj.save(out_jams)

        audiofile = os.path.join(out_dir, osp.splitext(osp.basename(jam_file))[0] + ".wav")
        LOG.debug(audiofile)
        scaper.generate_from_jams(out_jams, audiofile)


def modify_fg_onset(added_value, jam_file):
    """ Add a value foreground onset of a JAMS generated by scaper (containing a single event)
    Args:
        added_value: float, value in seconds, value to be added to previous onset
        jam_file: str, the name of the JAMS file to change the background SNR

    Returns:
        jams object that has been modified
    """
    jam_obj = jams.load(jam_file)
    data = jam_obj["annotations"][0].data
    for cnt, obs in enumerate(data):
        if obs.value["role"] == "foreground":
            onset = obs.value["event_time"]
            # Change source time by adding the added value specified
            jam_obj["annotations"][0].data[cnt].value["event_time"] = onset + added_value
            # Todo, this is tricky, because it is an object, find a better way to do that with Scaper
            new_obs = jam_obj["annotations"][0].data[cnt]._replace(time=onset + added_value)
            del jam_obj["annotations"][0].data[cnt]
            jam_obj["annotations"][0].data.add(new_obs)

    return jam_obj


def generate_new_fg_onset_files(added_value, in_dir, out_dir):
    """ Generate the new JAMS and audio files adding a value to forground onsets
    Args:
        added_value: float, value in seconds, value to be added to previous onset
        in_dir: str, folder containing JAMS file with background SNR to be changed
        out_dir: str, folder where to save the new audio and JAMS

    Returns:

    """
    LOG = create_logger(__name__, "Desed.log")
    for jam_file in sorted(glob.glob(os.path.join(in_dir, "*.jams"))):
        jams_obj = modify_fg_onset(added_value, jam_file)
        out_jams = osp.join(out_dir, os.path.basename(jam_file))
        jams_obj.save(out_jams)

        audiofile = os.path.join(out_dir, osp.splitext(osp.basename(jam_file))[0] + ".wav")
        LOG.debug(audiofile)
        scaper.generate_from_jams(out_jams, audiofile)


def generate_single_file(class_params, class_lbl, ref_db, duration, fg_folder, bg_folder, outfolder, filename,
                         min_events=0):
    # create a scaper
    sc = scaper.Scaper(duration, fg_folder, bg_folder)
    sc.protected_labels = []
    sc.ref_db = ref_db

    # add background
    sc.add_background(label=('choose', []),
                      source_file=('choose', []),
                      source_time=('const', 0))

    # add main event
    sc = add_event(sc, class_lbl, duration, fg_folder)

    # add random number of foreground events
    n_events = np.random.randint(min_events, class_params['event_max'])
    for _ in range(n_events):
        chosen_class = choose_class(class_params)
        sc = add_event(sc, chosen_class, duration, fg_folder)

    # generate
    audiofile = osp.join(outfolder, f"{filename}.wav")
    jamsfile = osp.join(outfolder, f"{filename}.jams")
    txtfile = osp.join(outfolder, f"{filename}.txt")

    sc.generate(audiofile, jamsfile,
                allow_repeated_label=True,
                allow_repeated_source=True,
                reverb=0.1,
                disable_sox_warnings=True,
                no_audio=False,
                txt_path=txtfile)


def generate_files_from_jams(list_jams, outfolder, fg_path=None, bg_path=None, overwrite_jams=False):
    """ Generate audio files from jams files generated by Scaper

    Args:
        list_jams: list, list of jams filepath generated by Scaper.
        outfolder: str, output path to save audio files.
        fg_path: str, optional, path of the foreground files to generate audio if different from the one used to
            generate JAMS
        bg_path: str, optional, path of the background files to generate audio if different from the one used to
            generate JAMS
        overwrite_jams: bool, overwrite the input JAMS with generated ones (update fg and bg path for example)

    Returns: None

    """
    LOG = create_logger(__name__, "Desed.log")
    LOG.info(f"generating audio files to {outfolder}")
    create_folder(outfolder)
    n = 0
    for jam_file in list_jams:
        LOG.debug(jam_file)
        audiofile = osp.join(outfolder, f"{osp.splitext(osp.basename(jam_file))[0]}.wav")
        if overwrite_jams:
            jams_outfile = jam_file
        else:
            jams_outfile = None
        generate_from_jams(jam_file, audiofile, fg_path=fg_path, bg_path=bg_path, jams_outfile=jams_outfile)

        n += 1
        if n % 500 == 0:
            LOG.debug(f"generating {n} / {len(list_jams)} files")
    LOG.info("Done")


def generate_multi_common(number, ref_db, duration, fg_folder, bg_folder, outfolder, min_events, max_events,
                          labels=('choose', []), source_files=('choose', []), sources_time=('const', 0),
                          events_time=('truncnorm', 5.0, 2.0, 0.0, 10.0), events_duration=('uniform', 0.25, 10.0),
                          snrs=('const', 30), pitch_shifts=('uniform', -3.0, 3.0), time_stretches=('uniform', 1, 1),
                          txt_file=True):
    LOG = create_logger(__name__)
    params = {
        'labels': labels,
        'source_files': source_files,
        'sources_time': sources_time,
        'events_time': events_time,
        'events_duration': events_duration,
        'snrs': snrs,
        'pitch_shifts': pitch_shifts,
        'time_stretches': time_stretches
    }

    for n in range(number):
        LOG.debug('Generating soundscape: {:d}/{:d}'.format(n + 1, number))
        # create a scaper
        n_events = np.random.randint(min_events, max_events + 1)
        generate_one_bg_multi_fg(ref_db=ref_db,
                                 duration=duration,
                                 fg_folder=fg_folder,
                                 bg_folder=bg_folder,
                                 out_folder=outfolder,
                                 filename=n,
                                 n_events=n_events,
                                 **params,
                                 txt_file=txt_file)


def generate_csv_from_jams(list_jams, csv_out, post_process=True, background_label=False):
    """ In scaper generate, they create txt files, using the same idea, we create a single csv file.

    Returns:

    """
    final_df = pd.DataFrame()
    for jam_file in list_jams:
        print(jam_file)
        fbase = osp.basename(jam_file)
        df, length = get_df_from_jams(jam_file, background_label=background_label, return_length=True)

        if post_process:
            df, _ = post_process_df(df, length)

        df["filename"] = fbase
        final_df = final_df.append(df[['filename', 'onset', 'offset', 'event_label']], ignore_index=True)

    final_df = final_df.sort_values(by=["filename", "onset"])
    final_df.to_csv(csv_out, sep="\t", index=False, float_format="%.3f")


def generate_one_bg_multi_fg(ref_db, duration, fg_folder, bg_folder, out_folder, filename, n_events,
                             labels=('choose', []), source_files=('choose', []), sources_time=('const', 0),
                             events_time=('truncnorm', 5.0, 2.0, 0.0, 10.0), events_duration=("uniform", 0.25, 10.0),
                             snrs=("const", 30), pitch_shifts=('uniform', -3.0, 3.0),
                             time_stretches=('uniform', 1, 1), txt_file=True):
    sc = scaper.Scaper(duration, fg_folder, bg_folder)
    sc.protected_labels = []
    sc.ref_db = ref_db

    # add background
    sc.add_background(label=('choose', []),
                      source_file=('choose', []),
                      source_time=('const', 0))

    params = {"label": labels, "source_file": source_files, "source_time": sources_time, "event_time": events_time,
              "event_duration": events_duration, "snr": snrs, "pitch_shift": pitch_shifts,
              "time_stretch": time_stretches}
    for i in range(n_events):
        event_params = {}
        for key in params:
            if type(params[key]) is tuple:
                param = params[key]
            elif type(params[key]) is list:
                assert len(params[key]) == n_events
                param = params[key][i]
            else:
                NotImplementedError("Params of events is tuple(same for all) or list (different for each event)")
            event_params[key] = param

        sc.add_event(**event_params)

    # generate
    audiofile = osp.join(out_folder, f"{filename}.wav")
    jamsfile = osp.join(out_folder, f"{filename}.jams")
    if txt_file:
        # Can be useless if you want background annotation as well, see post_processing_annotations.
        txtfile = osp.join(out_folder, f"{filename}.txt")
    else:
        txtfile = None
    sc.generate(audio_path=audiofile, jams_path=jamsfile,
                allow_repeated_label=True,
                allow_repeated_source=True,
                reverb=0.1,
                disable_sox_warnings=True,
                no_audio=False,
                txt_path=txtfile)